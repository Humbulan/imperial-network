import os
DATABASE = os.path.join(os.path.dirname(__file__), "instance", "imperial.db")

from datetime import timezone
import os
import sqlite3
import secrets
from datetime import datetime, timedelta
from functools import wraps
from flask import g
import datetime
import sqlite3
import secrets
from datetime import datetime, timedelta
from functools import wraps
from flask import g

from flask import Flask, render_template, request, redirect, url_for, flash, jsonify, send_file
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from Crypto.Hash import SHA256
from datetime import datetime, timedelta
from dotenv import load_dotenv
import os
import io
import random

# Load environment variables FIRST
load_dotenv()

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('FLASK_SECRET_KEY', 'imperial_secret_123')
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///imperial.db'
db = SQLAlchemy(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'

def hash_password(password):
    return SHA256.new(password.encode()).hexdigest()

# ==================== MODELS ====================
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    role = db.Column(db.String(20), default='user')
    phone = db.Column(db.String(20), nullable=True)
    village = db.Column(db.String(100), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Order(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    order_number = db.Column(db.String(50), unique=True)
    customer_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    description = db.Column(db.Text)
    amount = db.Column(db.Float)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Payment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    payment_id = db.Column(db.String(50), unique=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    amount = db.Column(db.Float)
    payment_method = db.Column(db.String(50))
    status = db.Column(db.String(20), default='completed')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class USSDSession(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    session_id = db.Column(db.String(100), unique=True)
    phone_number = db.Column(db.String(20))
    current_menu = db.Column(db.String(50), default='main')
    amount = db.Column(db.Float, default=0)
    recipient = db.Column(db.String(100))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id))

# ==================== WEB ROUTES ====================
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        hashed = hash_password(request.form['password'])
        new_user = User(
            username=request.form['username'],
            email=request.form['email'],
            password=hashed,
            phone=request.form.get('phone', '')
        )
        db.session.add(new_user)
        db.session.commit()
        flash('Registration successful! Please login.')
        return redirect(url_for('login'))
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        
        user = User.query.filter_by(email=email).first()
        
        print(f"\n=== LOGIN DEBUG ===")
        print(f"Email: {email}")
        print(f"User found: {user is not None}")
        
        if user and user.password == hash_password(password):
                    login_user(user)
            session["role"] = user.role
            session["user_id"] = user.id
            flash('Login successful!', 'success')
            next_page = request.args.get('next')
            return redirect(next_page) if next_page else redirect(url_for('dashboard'))
        else:
            flash('Invalid email or password', 'danger')
            return render_template('login.html')
    
    return render_template('login.html')


@app.route('/dashboard')



@login_required



    def dashboard():
        # Ensure role is in session
        if "role" not in session and current_user.is_authenticated:
                session["role"] = current_user.role
                session["user_id"] = current_user.id
    
    
    
        orders = Order.query.filter_by(customer_id=current_user.id).all()

    payments = Payment.query.filter_by(user_id=current_user.id).all()

    

    stats = {

        'my_orders': len(orders),

        'my_payments': len(payments)

    }

    

    if current_user.role == 'admin':

        stats['total_users'] = User.query.count()

        stats['total_orders'] = Order.query.count()

        stats['total_payments'] = db.session.query(db.func.sum(Payment.amount)).scalar() or 0

    

    return render_template('dashboard.html', user=current_user, orders=orders, payments=payments, stats=stats)

@app.route('/logout')
def logout():
    logout_user()
    return redirect(url_for('index'))

# ==================== USER ACTIONS ====================
@app.route('/create_order', methods=['GET', 'POST'])
@login_required
def create_order():
    if request.method == 'POST':
        order_no = f"ORD-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        new_order = Order(
            order_number=order_no,
            customer_id=current_user.id,
            description=request.form.get('description'),
            amount=float(request.form.get('amount', 0))
        )
        db.session.add(new_order)
        db.session.commit()
        flash('Order created successfully!')
        return redirect(url_for('dashboard'))
    return render_template('create_order.html')

@app.route('/create_payment', methods=['GET', 'POST'])
@login_required
def create_payment():
    if request.method == 'POST':
        pay_id = f"PAY-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        new_payment = Payment(
            payment_id=pay_id,
            user_id=current_user.id,
            amount=float(request.form.get('amount', 0)),
            payment_method=request.form.get('method')
        )
        db.session.add(new_payment)
        db.session.commit()
        flash('Payment submitted!')
        return redirect(url_for('dashboard'))
    return render_template('create_payment.html')

@app.route('/my_orders')
@login_required
def my_orders():
    orders = Order.query.filter_by(customer_id=current_user.id).all()
    return render_template('my_orders.html', orders=orders)

@app.route('/my_payments')
@login_required
def my_payments():
    payments = Payment.query.filter_by(user_id=current_user.id).all()
    return render_template('my_payments.html', payments=payments)

# ==================== API ENDPOINTS ====================
@app.route('/api/health')
def api_health():
    return jsonify({
        'status': 'online',
        'timestamp': datetime.now(timezone.utc).isoformat(),
        'version': '2.0.0'
    })

@app.route('/api/version')
def api_version():
    return jsonify({
        'name': 'Imperial Network API',
        'version': '2.0.0',
        'status': 'operational',
        'endpoints': [
            '/api/health',
            '/api/version',
            '/api/system/status',
            '/api/business/data',
            '/api/mobile/config'
        ]
    })

@app.route('/api/system/status')
def system_status():
    return jsonify({
        'system': 'online',
        'timestamp': datetime.now(timezone.utc).isoformat(),
        'services': {
            'database': 'connected',
            'api': 'operational',
            'business_api': 'ready'
        }
    })

@app.route('/api/mobile/config')
def mobile_config():
    return jsonify({
        'app_name': 'Imperial Network',
        'version': '2.0.0',
        'api_base': 'http://10.69.206.69:8000/api',
        'features': {'orders': True, 'payments': True, 'ussd': True}
    })

@app.route('/api/business/data')
def business_api():
    """Premium business API endpoint - requires valid API key"""
    auth_header = request.headers.get('Authorization')
    
    if not auth_header:
        return jsonify({
            'error': 'Unauthorized',
            'message': 'Token required: Authorization: Bearer YOUR_TOKEN'
        }), 401
    
    token = auth_header.replace('Bearer ', '')
    expected_token = os.getenv('BUSINESS_API_KEY', 'PREMIUM_KEY_A1B2C3D4')
    
    print(f"\n{'='*40}")
    print(f"BUSINESS API ACCESS")
    print(f"{'='*40}")
    print(f"Token received: {token}")
    print(f"Expected token: {expected_token}")
    print(f"Match: {token == expected_token}")
    
    if token != expected_token:
        return jsonify({
            'error': 'Forbidden',
            'message': 'Invalid token'
        }), 403
    
    try:
        with app.app_context():
            total_users = User.query.count()
            total_revenue = db.session.query(db.func.sum(Payment.amount)).scalar() or 0
            
            return jsonify({
                'success': True,
                'business': {
                    'name': 'Imperial Network',
                    'status': 'premium',
                    'version': '2.0.0',
                    'stats': {
                        'total_users': total_users,
                        'total_revenue': float(total_revenue),
                        'active_villages': 50
                    },
                    'features': [
                        'ussd_gateway',
                        'ai_analytics',
                        'mobile_sdk',
                        'bulk_payments',
                        'business_api'
                    ]
                }
            })
    except Exception as e:
        print(f"ERROR in business_api: {str(e)}")
        return jsonify({
            'error': 'Server error',
            'message': str(e)
        }), 500

@app.route('/api/mobile/login', methods=['POST'])
def mobile_login():
    data = request.json
    user = User.query.filter_by(email=data.get('email')).first()
    if user and user.password == hash_password(data.get('password')):
        return jsonify({
            'success': True,
            'user': {'id': user.id, 'username': user.username, 'role': user.role},
            'token': f'token-{user.id}-{datetime.now(timezone.utc).timestamp()}'
        })
    return jsonify({'success': False, 'error': 'Invalid credentials'}), 401

# ==================== USSD SYSTEM ====================
@app.route('/ussd', methods=['GET', 'POST'])
def ussd_callback():
    session_id = request.values.get('sessionId', '')
    phone_number = request.values.get('phoneNumber', '')
    text = request.values.get('text', '')
    
    if text == '':
        response = "CON Welcome to Imperial\n1. Check Balance\n2. Send Money"
    elif text == '1':
        response = f"END Your balance: R{random.randint(100, 500)}.00"
    else:
        response = "END Transaction completed"
    
    return response

@app.route('/ussd/simulate', methods=['GET', 'POST'])
def ussd_simulate():
    result = None
    if request.method == 'POST':
        text = request.form.get('text', '')
        if text == '':
            result = "CON Welcome to Imperial\n1. Check Balance\n2. Send Money"
        elif text == '1':
            result = f"END Your balance: R{random.randint(100, 500)}.00"
        else:
            result = "END Transaction completed"
    return render_template('ussd_simulate.html', result=result)

@app.route('/ussd/admin')
@login_required
def ussd_admin():
    if current_user.role != 'admin':
        return redirect(url_for('dashboard'))
    stats = {"total_sessions": 0, "active_sessions": 0}
    return render_template("ussd_admin.html", stats=stats)


@app.route('/ai/dashboard')



@login_required



def ai_dashboard():



    if current_user.role != 'admin':



        return redirect(url_for('dashboard'))



    health = {"system_health": "99.9%", "active_services": 12, "total_services": 12}



    return render_template("ai_dashboard.html", health=health)



@app.route('/mobile')

@login_required

def mobile():

    return render_template('mobile.html')



@app.route('/mobile/sdk')

@login_required

def mobile_sdk():

    return render_template('mobile_sdk.html')



@app.route('/mobile/sdk/download')

@login_required

def mobile_sdk_download():

    sdk_content = "Imperial Mobile SDK v2.0.0\n\nAPI Documentation at /api/version"

    return send_file(

        io.BytesIO(sdk_content.encode()),

        mimetype='text/plain',

        as_attachment=True,

        download_name='imperial_sdk.txt'

    )



if __name__ == '__main__':

    with app.app_context():

        db.create_all()

    app.run(debug=True, host='0.0.0.0', port=8000)



# ==================== FULL SYSTEM MONITORING ====================

@app.route('/api/status/full')

@login_required

def full_status():

    """Comprehensive system status endpoint - Admin only"""

    if current_user.role != 'admin':

        return jsonify({'error': 'Unauthorized'}), 403

    

    # Check database connectivity

    db_status = 'connected'

    try:

        db.session.execute('SELECT 1').scalar()

    except:

        db_status = 'disconnected'

    

    # Get system stats

    total_users = User.query.count()

    total_orders = Order.query.count()

    total_payments = Payment.query.count()

    total_revenue = db.session.query(db.func.sum(Payment.amount)).scalar() or 0

    

    # Get recent activity

    recent_orders = Order.query.order_by(Order.created_at.desc()).limit(5).all()

    recent_payments = Payment.query.order_by(Payment.created_at.desc()).limit(5).all()

    

    # Get USSD session stats

    ussd_sessions = USSDSession.query.count()

    active_ussd = USSDSession.query.filter(

        USSDSession.updated_at > datetime.now(timezone.utc) - timedelta(minutes=5)

    ).count()

    

    return jsonify({

        'status': 'healthy',

        'timestamp': datetime.now(timezone.utc).isoformat(),

        'uptime': '99.9%',

        'services': {

            'database': db_status,

            'api': 'operational',

            'ussd_gateway': 'active' if ussd_sessions > 0 else 'standby',

            'ai_engine': 'running'

        },

        'statistics': {

            'users': {

                'total': total_users,

                'admins': User.query.filter_by(role='admin').count(),

                'regular': User.query.filter_by(role='user').count()

            },

            'orders': {

                'total': total_orders,

                'pending': Order.query.filter_by(status='pending').count(),

                'completed': Order.query.filter_by(status='completed').count()

            },

            'payments': {

                'total': total_payments,

                'total_revenue': float(total_revenue),

                'average': float(total_revenue / total_payments) if total_payments > 0 else 0

            },

            'ussd': {

                'total_sessions': ussd_sessions,

                'active_now': active_ussd

            }

        },

        'recent_activity': {

            'orders': [

                {

                    'id': o.order_number,

                    'amount': o.amount,

                    'status': o.status,

                    'time': o.created_at.isoformat()

                } for o in recent_orders

            ],

            'payments': [

                {

                    'id': p.payment_id,

                    'amount': p.amount,

                    'method': p.payment_method,

                    'time': p.created_at.isoformat()

                } for p in recent_payments

            ]

        },

        'endpoints': {

            'total': len([rule for rule in app.url_map.iter_rules()]),

            'api': [str(rule) for rule in app.url_map.iter_rules() if '/api/' in str(rule)]

        }

    })



@app.route('/monitor')

@login_required

def monitor():

    if current_user.role != 'admin':

        return redirect(url_for('dashboard'))

    return render_template('monitor.html')



# Village tables initialization



# API Key decorator

def require_api_key(tier=None):

    def decorator(f):

        @wraps(f)

        def decorated_function(*args, **kwargs):

            auth_header = request.headers.get('Authorization')

            if not auth_header or not auth_header.startswith('Bearer '):

                return jsonify({'error': 'No API key provided'}), 401

            api_key = auth_header.split(' ')[1]

            with sqlite3.connect(DATABASE) as conn:

                conn.row_factory = sqlite3.Row

                key_data = conn.execute('''SELECT ak.*, v.name as village_name, v.district, v.region 

                    FROM api_keys ak JOIN villages v ON ak.village_id = v.id

                    WHERE ak.key = ? AND ak.is_active = 1 

                    AND (ak.expires_at IS NULL OR ak.expires_at > CURRENT_TIMESTAMP)''', (api_key,)).fetchone()

                if not key_data:

                    return jsonify({'error': 'Invalid or expired API key'}), 401

                if tier and key_data['tier'] not in ['enterprise', tier]:

                    return jsonify({'error': f'This endpoint requires {tier} tier'}), 403

                if key_data['usage_count'] >= key_data['monthly_limit']:

                    return jsonify({'error': 'Monthly API limit exceeded'}), 429

                g.api_key_info = dict(key_data)

                g.api_key_id = key_data['id']

                return f(*args, **kwargs)

        return decorated_function

    return decorator



# Village management endpoints

@app.route('/api/admin/villages', methods=['GET'])

@login_required

def list_villages():

    if session.get('role') != 'admin':

        return jsonify({'error': 'Admin access required'}), 403

    with sqlite3.connect(DATABASE) as conn:

        conn.row_factory = sqlite3.Row

        villages = conn.execute('SELECT * FROM villages ORDER BY name').fetchall()

        return jsonify([dict(v) for v in villages])



@app.route('/api/admin/villages', methods=['POST'])

@login_required

def create_village():

    if session.get('role') != 'admin':

        return jsonify({'error': 'Admin access required'}), 403

    data = request.json

    with sqlite3.connect(DATABASE) as conn:

        cursor = conn.execute('''INSERT INTO villages (name, district, region, population)

            VALUES (?, ?, ?, ?)''', (data['name'], data['district'], data['region'], data.get('population', 0)))

        conn.commit()

        return jsonify({'message': 'Village created', 'village_id': cursor.lastrowid}), 201



@app.route('/api/admin/villages/<int:village_id>/keys', methods=['POST'])

@login_required

def generate_api_key(village_id):

    if session.get('role') != 'admin':

        return jsonify({'error': 'Admin access required'}), 403

    data = request.json

    api_key = f"IMP_{village_id}_{secrets.token_urlsafe(16)}"

    expires_at = datetime.now() + timedelta(days=365)

    with sqlite3.connect(DATABASE) as conn:

        village = conn.execute('SELECT id FROM villages WHERE id = ?', (village_id,)).fetchone()

        if not village:

            return jsonify({'error': 'Village not found'}), 404

        cursor = conn.execute('''INSERT INTO api_keys (key, village_id, name, tier, monthly_limit, expires_at)

            VALUES (?, ?, ?, ?, ?, ?)''', (api_key, village_id, data.get('name', 'Default Key'), 

            data.get('tier', 'basic'), data.get('monthly_limit', 10000), expires_at))

        conn.commit()

        return jsonify({'message': 'Key generated', 'api_key': api_key, 'key_id': cursor.lastrowid}), 201



@app.route('/api/admin/keys', methods=['GET'])

@login_required

def list_api_keys():

    if session.get('role') != 'admin':

        return jsonify({'error': 'Admin access required'}), 403

    with sqlite3.connect(DATABASE) as conn:

        conn.row_factory = sqlite3.Row

        keys = conn.execute('''SELECT ak.*, v.name as village_name FROM api_keys ak

            JOIN villages v ON ak.village_id = v.id ORDER BY ak.created_at DESC''').fetchall()

        return jsonify([dict(k) for k in keys])



@app.route('/api/village/stats')

@require_api_key()

def village_stats():

    with sqlite3.connect(DATABASE) as conn:

        conn.row_factory = sqlite3.Row

        orders = conn.execute('''SELECT COUNT(*) as total_orders, COALESCE(SUM(amount), 0) as total_value

            FROM orders o JOIN user u ON o.customer_id = u.id WHERE u.village = ?''', 

            (g.api_key_info['village_name'],)).fetchone()

        return jsonify({'village': g.api_key_info['village_name'], 'tier': g.api_key_info['tier'],

            'stats': dict(orders), 'timestamp': datetime.now().isoformat()})



@app.route('/admin/villages')

@login_required

def villages_dashboard():

    if session.get('role') != 'admin':

        return redirect('/dashboard')

    return render_template('villages_admin.html')



# Village tables initialization



# Village tables initialization

def init_village_tables():

    """Initialize village management tables"""

    global DATABASE

    with sqlite3.connect(DATABASE) as conn:

        conn.execute('''CREATE TABLE IF NOT EXISTS villages (

            id INTEGER PRIMARY KEY AUTOINCREMENT,

            name TEXT UNIQUE NOT NULL,

            district TEXT,

            region TEXT,

            population INTEGER,

            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP

        )''')

        conn.execute('''CREATE TABLE IF NOT EXISTS api_keys (

            id INTEGER PRIMARY KEY AUTOINCREMENT,

            key TEXT UNIQUE NOT NULL,

            village_id INTEGER NOT NULL,

            name TEXT,

            tier TEXT DEFAULT 'basic',

            monthly_limit INTEGER DEFAULT 10000,

            usage_count INTEGER DEFAULT 0,

            last_used TIMESTAMP,

            expires_at TIMESTAMP,

            is_active BOOLEAN DEFAULT 1,

            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

            FOREIGN KEY (village_id) REFERENCES villages (id)

        )''')

        conn.execute('''CREATE TABLE IF NOT EXISTS api_usage_logs (

            id INTEGER PRIMARY KEY AUTOINCREMENT,

            api_key_id INTEGER,

            endpoint TEXT,

            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

            response_time INTEGER,

            status_code INTEGER,

            FOREIGN KEY (api_key_id) REFERENCES api_keys (id)

        )''')

        conn.commit()



# Call the function

init_village_tables()

